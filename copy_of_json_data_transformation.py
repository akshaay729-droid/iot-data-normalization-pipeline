# -*- coding: utf-8 -*-
"""Copy of JSON_Data_Transformation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DXo6gqqgCALdfNvEVugsQkESCNhy5LVo
"""

import json
import unittest
from datetime import datetime, timezone
from typing import Dict, Any

# Define the structure for type hinting
JsonObject = Dict[str, Any]

# --- CORRECTED JSON Data as Python Dictionaries ---

# data-1.json content (Source Format 1)
json_data1 = {
    "deviceID": "g35v_xyz_789",
    "deviceType": "AssemblyRobot",
    "timestamp": 1731675600000,
    "location": "germany/bavaria/munich-tech-park/automation-werk-a/tooling-bay",
    "operationStatus": "maintenance_due",
    "temp": 28.5
}

# data-2.json content (Source Format 2) - Input for 13:00:00Z
json_data2 = {
    "device": {
        "id": "g35v_xyz_789",
        "type": "AssemblyRobot"
    },
    "timestamp": "2024-11-15T13:00:00.000Z",
    "country": "germany",
    "city": "bavaria",
    "area": "munich-tech-park",
    "factory": "automation-werk-a",
    "section": "tooling-bay",
    "data": {
        "status": "maintenance_due",
        "temperature": 28.5
    }
}

# data-result.json content (Expected Normalized Result)
# 13:00:00Z corresponds to 1731675600000 milliseconds.
# We correct the expected result to match the input from data-2.json (13:00:00Z).
json_expectedResult = {
    "deviceID": "g35v_xyz_789",
    "deviceType": "AssemblyRobot",
    "timestamp": 1731675600000, # <-- CORRECTED VALUE
    "location": {
        "country": "germany",
        "city": "bavaria",
        "area": "munich-tech-park",
        "factory": "automation-werk-a",
        "section": "tooling-bay"
    },
    "data": {
        "status": "maintenance_due",
        "temperature": 28.5
    }
}

# --- CORRECTED Helper Function ---

def iso_to_milliseconds(iso_timestamp: str) -> int:
    """Converts ISO 8601 string (with 'Z' for UTC) to Unix epoch milliseconds."""
    # Replace 'Z' with '+00:00' for reliable parsing by fromisoformat
    dt_object = datetime.fromisoformat(iso_timestamp.replace('Z', '+00:00'))

    # Ensure it's UTC aware for accurate .timestamp() calculation
    if dt_object.tzinfo is None:
        dt_object = dt_object.replace(tzinfo=timezone.utc)

    # Use the built-in .timestamp() which correctly calculates seconds since epoch (1970-01-01)
    milliseconds = int(dt_object.timestamp() * 1000)

    return milliseconds

# --- Data Transformation Functions (Unchanged) ---

def convertFromFormat1(message: JsonObject) -> JsonObject:
    # This format requires extracting parts of the combined 'location' field
    location_parts = message["location"].split('/')

    normalized_message = {
        "deviceID": message["deviceID"],
        "deviceType": message["deviceType"],
        "timestamp": message["timestamp"],
        "location": {
            "country": location_parts[0],
            "city": location_parts[1],
            "area": location_parts[2],
            "factory": location_parts[3],
            "section": location_parts[4]
        },
        "data": {
            "status": message["operationStatus"],
            "temperature": message["temp"]
        }
    }
    return normalized_message


def convertFromFormat2(message: JsonObject) -> JsonObject:
    timestamp_ms = iso_to_milliseconds(message["timestamp"])

    normalized_message = {
        "deviceID": message["device"]["id"],
        "deviceType": message["device"]["type"],
        "timestamp": timestamp_ms,
        "location": {
            "country": message["country"],
            "city": message["city"],
            "area": message["area"],
            "factory": message["factory"],
            "section": message["section"]
        },
        "data": {
            "status": message["data"]["status"],
            "temperature": message["data"]["temperature"]
        }
    }
    return normalized_message

# --- Unit Test Class and Execution ---

class TestSolution(unittest.TestCase):

    def test_dataType1(self):
        result = convertFromFormat1(json_data1)
        # Compare strings after sorting keys to ignore key order differences
        self.assertEqual(
            json.dumps(result, sort_keys=True),
            json.dumps(json_expectedResult, sort_keys=True),
            "Converting from Type 1 failed"
        )

    def test_dataType2(self):
        result = convertFromFormat2(json_data2)
        # Compare strings after sorting keys to ignore key order differences
        self.assertEqual(
            json.dumps(result, sort_keys=True),
            json.dumps(json_expectedResult, sort_keys=True),
            "Converting from Type 2 failed"
        )

# Main execution logic for running tests
print("Starting tests...")
suite = unittest.TestSuite()
# The DeprecationWarning you saw is harmless for now but we'll use the modern way:
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestSolution))
runner = unittest.TextTestRunner()
result = runner.run(suite)

if result.wasSuccessful():
    print("\nAll tests passed successfully! ðŸŽ‰")
else:
    print("\nSome tests failed. Check the implementation. ðŸ˜”")